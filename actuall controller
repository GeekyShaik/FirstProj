To create unit tests for both the `TemplateProfileService` and `ObjectProfileController`, you would typically use a testing framework like JUnit for Java along with Mockito for mocking dependencies. Here is a high-level structure of how the tests might look:

### For `TemplateProfileService`

```java
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import org.junit.Before;
import org.junit.Test;
import java.util.List;

public class TemplateProfileServiceTest {

    private TemplateProfileService serviceUnderTest;
    private OmMessageTemplateRepository mockTemplateRepository;
    private OmMsgTemplateChannelRepository mockChannelRepository;

    @Before
    public void setUp() {
        mockTemplateRepository = mock(OmMessageTemplateRepository.class);
        mockChannelRepository = mock(OmMsgTemplateChannelRepository.class);
        serviceUnderTest = new TemplateProfileService(mockTemplateRepository, mockChannelRepository);
    }

    @Test
    public void testGetTemplatesByNameAndVersion() {
        // Setup mock behavior
        // e.g., when(mockTemplateRepository.findOmMsgTemplateEntityByOmMsgTemplateEntityPK_TemplateNameAndOmMsgTemplateEntityPK_TemplateVersion(templateName, templateVersion)).thenReturn(...);

        // Call the method under test
        List<TemplateProfileDto> result = serviceUnderTest.getTemplatesByNameAndVersion("templateName", 1);

        // Assertions
        // e.g., assertNotNull(result);
        // e.g., verify(mockTemplateRepository).findOmMsgTemplateEntityByOmMsgTemplateEntityPK_TemplateNameAndOmMsgTemplateEntityPK_TemplateVersion(anyString(), anyInt());
    }
    // Additional test cases...
}
```

### For `ObjectProfileController`

```java
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@WebMvcTest(ObjectProfileController.class)
public class ObjectProfileControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private TemplateProfileService mockTemplateProfileService;

    @Test
    public void testGetTemplateProfile() throws Exception {
        // Define mock behavior
        // e.g., when(mockTemplateProfileService.getTemplatesByNameAndVersion(anyString(), anyInt())).thenReturn(...);

        // Perform GET request
        mockMvc.perform(get("/template-details/template-name/{templateName}/template-version/{templateVersion}", "templateName", 1))
                .andExpect(status().isOk());

        // Additional assertions and verify
    }
    // Additional test cases...
}
```

In the `TemplateProfileServiceTest`, you mock the dependencies `OmMessageTemplateRepository` and `OmMsgTemplateChannelRepository` and test the `getTemplatesByNameAndVersion` method. You would define expected behavior, invoke the method, and assert the results.

In the `ObjectProfileControllerTest`, you mock the `TemplateProfileService` since it's a dependency of the controller. You perform mock MVC calls to your endpoints and assert the HTTP response and, optionally, the returned content.

Remember to extend these examples with more test methods to cover different scenarios, error cases, and input variations to thoroughly test your service and controller. Also, consider adding integration tests that involve the actual database and application context for a more end-to-end testing approach.